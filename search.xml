<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (三)]]></title>
    <url>%2F2019%2F08%2F16%2Fvar%20let%E5%92%8Cconst(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (三)前言在前一篇文章中，我们讲到了 var、let 和 const 有关的变量提升和函数提升。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 今天，我们来学习下 var、let 和 const的其他区别点：暂时性死区，重复声明和初始值 1. 暂时性死区(1) 什么是暂时性死区ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”（Temporal Dead Zone，简称 TDZ）。 理解：只要块级作用域内存在 let 或 const 命令，它所声明的变量就绑定（binding）这个区域，不再受外部影响。当进入这个区域，let 或者const 声明的变量不能被访问（获取或设置）直到执行到达声明。 123456789101112if (true) &#123; // TDZ 开始 tmp = 'a'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ 结束 console.log(tmp); // undefined tmp = 1; console.log(tmp); // 1 &#125; 代码理解：在块级作用域内，一开始存在全局变量 tmp。但是，接下来的 let 声明了一个局部变量 tmp，导致后者绑定了这个块级作用域。所以在 let 声明变量前，对 tmp 赋值会报错（ReferenceError）。 本质：只要一进入块级作用域，所要使用的变量 tmp 就已经存在了，但是不可获取。只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 (2) typeof 陷阱 当一个变量没有被声明时，使用 typeof 是不会报错的 1typeof undeclared_variable // "undefined" undeclared_variable 是一个不存在的变量名，结果返回“undefined” “暂时性死区” 意味着 typeof 不再是一个百分之百安全的操作。 12typeof x; // 报错！ ReferenceErrorlet x; 变量 x 使用 let 命令声明，所以在声明之前，都属于 x 的“暂时性死区”，只要用到该变量就会报错。 因此，typeof 运行时就会抛出一个ReferenceError 总结： typeof运算符并非是百分之百安全的，因此我们要养成良好的编程习惯，变量一定要在声明之后使用，否则就报错 （3） 其他例子实际上，有些 “死区” 比较隐蔽，不太容易发现。 1234function fun(x = y, y = 2) &#123; return [x, y];&#125;fun(); // 报错 上面代码中，调用 fun 函数之所以报错（某些实现 可能不会报错），是因为参数 x 默认值等于另一个参数 y ，而此时 y 还没有声明，属于”死区“。 如果 y 的默认值是 x ，就不会报错，因为此时 x 已经声明了。 1234function fun(x = 2, y = x) &#123; return [x, y];&#125;fun(); // [2, 2] 此外，下面的代码也会报错，与 var 的行为不同。 123456// 不报错var x = x;// 报错let x = x; // ReferenceError 上面代码报错，也是因为暂时性死区。使用 let 声明变量时，只要变量在还没有声明完成前使用，就会报错。 上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x未定义“。 (4) 总结ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 2. 重复声明定义：指在相同作用域内，重复声明同一个变量。 let 和 const 命令声明的变量不允许重复声明，而 var 可以重复声明。 在一个作用域中，已经用 var、let、cons t声明过某标识符之后，不能在用 let、const声明变量，不然会抛出错误。 12345678let a = 1;let a = 0; // 报错! Uncaught SyntaxError: Identifier 'a' has already been declaredconst PI = 3.14const PI = 3.1415 // 报错! Uncaught SyntaxError: Identifier 'a' has already been declaredvar b = 1;var b = 0; 在作用域中,嵌套一个作用域就不会报错了 12345var a = 1;if (true) &#123; let a = 0;&#125;// 不会报错 3. 初始值 和 const let 和 var 声明变量时，可以不需要初始值，而 const 需要。 const 声明的是只读的常量，一旦声明，就必须立即初始化（赋值），否则会报错 const 声明之后 值不能改变。 123const PI = 3.14;PI = 3.1415; // 报错! Uncaught TypeError: Assignment to constant variable. 如果 const 声明的是一个引用类型，则不能改变它的内存地址 本质：const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个 内存地址所保存的数据 不得改动。 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。 对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 举例如下 12345678const obj = &#123; a : '123'&#125;obj.a = 'abc';// 不会发生报错，只会改变值obj = &#123;&#125;;// 由于改变了对象的指针，所以会发生报错 // Uncaught TypeError: Assignment to constant variable. 如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze(&#123;&#125;); // 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 补充：顶层对象的属性let、const 和 class 命令声明的全局变量，不属于顶层对象的属性。 从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 全局作用域中，var 声明的变量关联到顶层对象的属性 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 参考文章 阮一峰 ECMAScript 6 入门]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (二)]]></title>
    <url>%2F2019%2F08%2F15%2Fvar%20let%E5%92%8Cconst(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (二)前言在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。在前一篇文章中，我们讲到了 var、let 和 const 的块级作用域，今天我们主要学习下变量提升和函数提升。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 1. 变量提升定义：变量提升，即将变量声明提升到它所在作用域的最开始的部分。变量声明在编译阶段被处理，而变量赋值则留在原地等待执行。 var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 let 和 const不存在变量提升，所声明的变量一定要在声明后使用，否则报错。 下面给出代码来解释 var 命令 — 存在变量提升12345678910console.log(global); // undefinedvar global = 'global';console.log(global); // global function fn () &#123; console.log(a); // undefined var a = 'a'; console.log(a); // a&#125;fn(); 由于js的变量提升，导致代码实际上是按照以下来执行的 123456789101112var global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值console.log(global); // undefinedglobal = 'global'; // 此时才赋值console.log(global); // globalfunction fn () &#123; var a; // 变量提升，函数作用域范围内 console.log(a); // undefined a = 'a'; console.log(a); // a&#125;fn(); let — 不存在变量提升123console.log(a);let a = 1;//报错! Uncaught ReferenceError: Cannot access 'a' before initializatio const — 不存在变量提升 123console.log(a);const a = 1;//报错! Uncaught ReferenceError: Cannot access 'a' before initializatio 使用 let 和 const 命令声明变量之前，该变量是不可用的。 2. 函数提升​ JavaScript中，创建函数主要有两种方式：函数声明式和函数表达式。 1) 函数声明 (Function Declaration); 1234// 函数声明function funDeclaration(type)&#123; return type === "Declaration";&#125; 2) 函数表达式 (Function Expression)。 123456// 函数表达式var funExpression = function(type)&#123; return type === "Expression";&#125;// 或者let、const ​ 编译阶段，JavaScript 引擎能把 函数声明 提升到顶部（即使声明函数的代码在调用它的代码后面） 函数声明提升优先于变量声明 (函数的提升优先级最高)。 函数声明提升优于函数表达式(函数表达式实际上是变量声明的一种)。 下面给出代码来解释 函数声明 12345console.log(fn(1)); function fn(a) &#123; return a&#125;// 1 由于函数提升，函数声明被置于执行环境顶部，即使调用函数的代码在声明函数之前也可以正确访问。 函数表达式 var 123456789101112console.log(fn(1)); var fn = function (a) &#123; return a;&#125;//报错！Uncaught TypeError: fn is not a function// 相当于var fn;console.log(fn(1));fn = function (a) &#123; return a;&#125; let（const和let类似） 12345console.log(fn(1)); let fn = function (a) &#123; return a;&#125;// 报错！Uncaught ReferenceError: Cannot access 'fn' before initialization]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (一)]]></title>
    <url>%2F2019%2F08%2F13%2Fvar%20let%E5%92%8Cconst(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (一)前言ES6新增了 let 和 const 两个关键字 ，用于声明变量，这两个命令和 var 有很多不同之处，两者之间也有一些细微的差别。 let 和 const 的用法类似于 var，但是 let 只在所在的代码块内有效，所以我们一般使用 let 替代 var, 用 const 来声明常量。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 今天我们主要学习下块级作用域。 块级作用域(1) ES5没有块级作用域​ 在ES6之前，没有块级作用域的概念，只有两种作用域，函数作用域和全局作用域。 所有的变量和函数声明都存在于这两种作用域中。 (2) 什么是块级作用域？我找了个定义如下： 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 举个例子 123456789101112// 例子1for(var i = 0; i &lt; 10; i++) &#123; console.log(i); // 最后一次循环i=9，循环结束i++后，i=10&#125;console.log(i);// 跳出 for 循环了，这里仍可以使用i变量// 例子2for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000);&#125; 执行例子1时，外层 console.log 会输出10，这是因为使用var声明的变量不具备块级作用域的特性。变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 执行例子2时，console.log 会输出10个10，这是因为 循环本身及十次 timeout 回调均共享唯一的变量 i 。当循环结束执行时，i 的值为10。 所以当第一个 timeout 执行时，调用的 i 为10。 注意：如果初始化变量时，没有使用 var声明，该变量会自动被添加到全局环境。 (3) ES5怎么创建块级作用域？立即执行函数“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 想进一步了解立即执行函数，可参考学习 IIFE学习 123(function() &#123; // 这里是块级作用域&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。 立即执行函数也可以理解为立即调用一个匿名函数，可以用来模拟块级作用域。 (4) ES6中的块级作用域在ES6中，我们用 let 和 const 关键字来实现块级作用域。（跨级作用域的特性，let，const是类似的，因此主要讲let） let声明的变量，只在所在的代码块{}内有效，在{}外不能访问（外层代码块不受内层代码块的影响） 1234&#123; let x = 1;&#125;// 此处不能使用x变量，否则报错 Uncaught ReferenceError: x is not defined for 循环中使用let，每一次循环的i其实都是一个新的变量 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了 参考文章：https://juejin.im/post/59e6a86d518825422c0cbb6f]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中JSON 类型 —— 数据的迭代]]></title>
    <url>%2F2019%2F08%2F10%2FJSON%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JS 中 JSON 类型—— 数据的迭代0. 什么是JSON？​ JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式，JSON 数据格式与语言无关，脱胎自JavaScript，但目前很多编程语言都支持JSON 格式数据的生成和解析（维基）。 1. json类型的数据​ JavaScript中，json类型的数据，有两种形式，一种是数组形式，另一种是对象形式 注意：json 与 js对象的区别 A. 为了统一解析，JSON的字符串规定必须用双引号&quot;&quot;，Object的键也必须用双引号&quot;&quot; B. JSON键值对中的值不能为方法、函数/undefined/NaN 数组形式用下标来定位元素，数组内的元素是对象形式的json数据 1234json1 = [ &#123;"key1":"value1"&#125;, &#123;"key2":"value2"&#125;] ​ 数组格式的json的迭代，可以使用js数组的遍历和迭代函数实现。 12345678910111213141516171819202122232425// 1.数组形式json_array = [ &#123;"key1":"value1"&#125;, &#123;"key2": [ &#123;"key21": "value21"&#125;, &#123;"key22": "value22"&#125; ] &#125;,]// 1）for infor (let key in json_array)&#123; console.log(key,json_array[key])&#125;// 2) for offor (let item of json_array)&#123; console.log(item)&#125;// 3) forEachjson_array.forEach(item=&gt; console.log(item)) 对象形式 1234567json2 = &#123; &quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:[ &#123;&quot;key21&quot;: &quot;value21&quot;&#125;, &#123;&quot;key22&quot;: &quot;value22&quot;&#125; ]&#125; ​ 对象格式的json的迭代，可以使用js对象的遍历方式实现。 12345678910111213141516171819202122232425262728// 2.对象形式json_obj = &#123; "key1":"value1", "key2":[ &#123;"key21": "value21"&#125;, &#123;"key22": "value22"&#125; ]&#125;// 1) for infor(let i in json_obj)&#123; console.log(i,json_obj[i])&#125;// 2) Object.keysObject.keys(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;)// 3) Reflect.ownKeysReflect.ownKeys(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;)// 4) Object.getOwnPropertynamesObject.getOwnPropertyNames(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;) 思考 — 若对象形式的json数据，存在多级嵌套，则用递归处理 综合两种形式和嵌套的json迭代函数——json_iteration 12345678910json_iteration = function(json)&#123; for(let key in json)&#123; if (typeof(json[key]) == 'object') &#123; json_iteration(json[key]) &#125; else&#123; console.log(key,json[key]) &#125; &#125;&#125;]]></content>
      <tags>
        <tag>JS</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F04%2F22%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 搭建个人博客什么是 Hexo？​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 在本地安装Hexo框架安装前提​ 在安装Hexo前，必须检查电脑中是否已安装下列应用程序（请自行Google，查询安装方法）： Node.js Git 安装Hexo使用 npm 安装 Hexo 12# 安装 Hexo 提供的脚手架 hexo-cli$ npm install -g hexo-cli 初始化Hexo初始化博客（此处命名为MyBlog，读者可以任意） 123456# 初始化$ hexo init MyBlog$ cd MyBlog# 安装依赖$ npm install 此时， blog文件下的目录如下： 1234567.├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 运行1234# 启动博客$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 浏览器查看在浏览器中打开 http://localhost:4000 ，页面呈现Hexo 默认主题的博客站点。 Hexo 常用命令1234567891011$ hexo new &quot;MyBlog&quot; # hexo n$ hexo publish # hexo p$ hexo generate # hexo g 生成静态网页$ hexo deploy # hexo d 开始部署$ hexo server # hexo s # Hexo 会监视文件变动并自动更新，无须重启服务器$ hexo server -s # 静态模式$ hexo server -p 8000 # 更改8000端口$ hexo server -i 192.168.1.0 # 定义 IP$ hexo clean # 清除缓存，网页正常情况下可以忽略此条命令 参考资料Hexo 官方文档]]></content>
      <tags>
        <tag>Front End</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小白入门]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 前端小白入门0. 前言前端开发入门学习有：HTML、CSS、JavaScript（简称JS） 三个部分。一个基本的网站可以由多个网页组成，一个基本的网页由HTML CSS和JavaScript组成，也即结构层(HTML)、表示层(CSS)、行为层(Javascript)。 1. 简介(1) HTML（超文本标记语言 Hyper Text Markup Language）HTML 是用来描述网页的一种语言。它通过标记符号来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（比如文字如何处理，画面如何安排，图片如何显示等）。浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容. (2) CSS(层叠样式表 Cascading Style Sheets)样式表定义如何显示 HTML 元素，就像 HTML的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。 (3) JS( JavaScript)Javascript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言。使用它的目的是与HTML超文本标记语言、Java脚本语言(Java小程序)一起实现在一个Web页面中链接多个对象，与Web客户交互作用。例如可以设置鼠标悬停效果，在客户端验证表单，创建定制的HTML页面，显示警告框，设置cookie等等。 (4) 联系简单来说（不严谨），Html就是框架，就是一个房子的顶梁柱，CSS就是刷墙的颜料，美化HTML，JavaScript是让HTML更生动，更好看，让网页会动起来（比如图片滚动） 2. 学习路线个人经验，学习前端的路线应该是Html(Html5)—&gt; CSS(CSS3)—&gt;JS—&gt;Jquery，由浅入深。学打好基础，学好html和css基础，再学JS（要求先掌握基本语法，再学应用，有点难，必须深入学习） 以下是个人觉得入门阶段应该熟练掌握的基础技能： HTML4，HTML5语法、标签、语义（基础） CSS2.1，CSS3规范，与HTML结合实现各种布局、效果（基础） 一个成熟的客户端javascript库，推荐jquery 一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟， HTTP 比较好的在线学习资源有 W3School 和 菜鸟教程，当然阅读官方文档学习是更好的选择 本文在此对HTML、CSS、JS的学习进行粗略介绍。 3. HTML HTML文档的后缀名 .html .htm Html的入门学习包括 Html文档结构，头部标签，文本标签，表格标签，超链接标签，图像标签，HTML5音频、视频标签，HTML5绘图标签，框架标签（不需重点学习），&lt; div &gt;标签，颜色设置，绝对路径和相对路径。 简单例子 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;前端小白&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS CSS文件的后缀名 .css CSS的定义分类 CSS的定义可以直接放在HTML元素的标签中，称为内联样式。其形式如下： 1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;This is a paragraph.&lt;/p&gt; CSS的定义可以放在HTML文件的 &lt;style&gt; 标签中，称为内部样式表。其形式如下： 1&lt;head&gt;&lt;style&gt;body&#123;background-color:yellow;&#125;&lt;/style&gt; &lt;/head&gt; CSS的定义也可以独立保存在一个扩展名为 .css的文件中，通过链接的方式包含在网页中，称为外部样式表。其形式如下： 1&lt;head&gt;&lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;foo.css&quot;&gt;&lt;/head&gt; CSS的入门学习包括 选择符，CSS的层叠性与优先次序，CSS文本属性，CSS表格属性，CSS的盒子模型和网页布局方式（定位功能和定位方式）。 5. JS JS文件的后缀名 .js JS的基本语法 必须掌握：常量和变量，数据类型，表达式和运算符，两种语句（循环和条件）以及最重要的函数。 CSS的入门学习包括 基本语法，面向对象特性（类和对象，内置对象，异常处理），在浏览器的应用（浏览器对象，JS在DOM中的应用方式，事件驱动和界面交互，JS在html5的应用等等。 6. 基本开发工具好用的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并解决问题，以下是个人觉得必备的前端开发工具： 文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便，当然notepad++，VScode等也是不错的选择。 浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持 调试工具：推荐Chrome自带的Chrome develop tools（F12），可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等 辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools（另学） 7. 后言学习方法 入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果（不喜欢看书籍的直接第二步） 在具备一定基础之后可以上网搜各种教程（包括视频教程，比如慕课网，网易云课堂）、demo，了解各种功能的实际用法和常见功能的实现方法 阅读HTML，CSS，JavaScript标准全面完善知识点 阅读前端牛人的博客、文章提升对知识的理解 善用搜索引擎（Google最好）]]></content>
      <tags>
        <tag>Front End</tag>
      </tags>
  </entry>
</search>
