<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TS 入门和Vue实践]]></title>
    <url>%2F2021%2F04%2F10%2Fts%2Bvue%2F</url>
    <content type="text"><![CDATA[一、TS 快速上手 从 JavaScript 程序员的角度总结思考，快速上手理解 TypeScript。 1. 关于TSTypeScript 是 JavaScript 的一个超集，可以编译成纯 JavaScript。TypeScript 在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。 TypeScript 提供最新的和不断发展的 JavaScript 特性，下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系： 2. 基础2.1 基本语法1:&lt;TypeAnnotation&gt; TypeScript的基本类型语法是在变量之后使用冒号进行类型标识，这种语法也揭示了TypeScript的类型声明实际上是可选的。 (1) 原始值类型1234567let bool: boolean = false;let num: number = 10;let str: string = 'sip';// var bool = false;// var num = 10;// var str = 'sip'; (2) 特殊类型 Any 任意值（Any）用来表示允许赋值为任意类型。 在任意值上访问任何属性 / 调用任何方法都是允许的 12let notSure: any = 'any';notSure = 1; 未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 12let something;// 等同于 let something: any; Void void 类型像是与 any 类型相反，它表示没有任何类型 ；在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function alertName(): void &#123; alert('My name is Tom');&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined 12let u: undefined = undefined;let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12345// 这样不会报错let num: number = undefined;// 这样也不会报错let u: undefined;let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量： 1234let u: void;let num: number = u;// Type 'void' is not assignable to type 'number'. 2.2 类型推论 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 以下代码虽然没有指定类型，但是会在编译的时候报错： 1234let num = 'seven';num = 7;// error TS2322: Type '7' is not assignable to type 'string'. 事实上，它等价于： 1234let num: string = 'seven';num = 7;// error TS2322: Type '7' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let num;num = 'seven';num = 7; 2.3 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 12345678let strNum: string | number;strNum = 'seven';strNum = 7;let strNum2: string | number;strNum2 = true;// error TS2322: Type 'true' is not assignable to type 'string | number' 2.4 对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。 例子 12345678910// 接口 Person (接口一般首字母大写)interface Person &#123; name: string; age: number;&#125;let man: Person = &#123; name: 'Tom', age: 25&#125;; 定义的变量比接口多/少了一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致 (1) 可选属性 可选属性的含义是该属性可以不存在，但不允许添加未定义的属性： 1234567891011121314151617181920interface Person &#123; name: string; age?: number;&#125;let man: Person = &#123; name: 'Tom'&#125;;let man2: Person = &#123; name: 'Tom', age: 25&#125;;let man3: Person = &#123; name: 'Tom', tel: '1370000000'&#125;;// error TS2322: Type '&#123; name: string; tel: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'tel' does not exist in type 'Person'. (2) 任意属性 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let man: Person = &#123; name: 'Tom', gender: 'male'&#125;; 使用 [propName: string] 定义了任意属性取 string 类型的值。 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型： (3) 只读属性 123456789101112131415interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let man: Person = &#123; id: 99999, name: 'Tom', gender: 'male'&#125;;man.id = 10000;// error TS2540: Cannot assign to 'id' because it is a read-only property. 2.5 数组的类型 类型 + 方括号 数组的项中不允许出现其他的类型： 123let fibonacci: number[] = [1, '1', 2, 3, 5];// Type 'string' is not assignable to type 'number'. 数组泛型 1let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5]; 用接口表示数组 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 类数组 类数组（Array-like Object）不是数组类型，比如 arguments： 1234567function sum() &#123; let args: &#123; [index: number]: any; length: number; callee: Function; &#125; = arguments;&#125; any 在数组中的应用 1let list: any[] = ['1', 1, &#123; key: 'value' &#125;]; 2.6 函数的类型 函数声明 12345678function sum(x: number, y: number): number &#123; return x + y;&#125;// 注意，输入多余的（或者少于要求的）参数，是不被允许的：sum(1, 2, 3);// error TS2554: Expected 2 arguments, but got 3.sum(1);// error TS2554: Expected 2 arguments, but got 1. 函数表达式 123let mySum = function (x: number, y: number): number &#123; return x + y;&#125;; 上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。 如果需要我们手动给 mySum 添加类型，则应该是这样： 123 let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;; 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 用接口定义函数的形状 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。 可选参数 前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了： 1234567891011function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName(undefined, 'Tom');// error TS1016: A required parameter cannot follow an optional parameter. 参数默认值 TypeScript 会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制 12345function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。 2.7 声明文件声明文件必需以 .d.ts 为后缀。 一般来说，ts 会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件。 declare 仅用来定义类型 declare var 声明全局变量 (declare let 和 declare const) declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 export 导出变量 export namespace 导出（含有子属性的）对象 export default ES6 默认导出 export = commonjs 导出模块 export as namespace UMD 库声明全局变量 declare global 扩展全局变量 declare module 扩展模块 /// 三斜线指令 3. 补充3.1 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 1234let strNumberList: [string, number];strNumberList = ['hello', 10]; // OKstrNumberList = [10, 'hello']; // webstorm会报红， 编译会出错 3.2 枚举enum类型是对JavaScript标准数据类型的一个补充。 123456789101112131415enum Color &#123;Red, Green, Blue&#125; // 默认从0开始编号let color: Color = Color.Green;// 编译后var Color;(function (Color) &#123; Color[Color["Red"] = 0] = "Red"; Color[Color["Green"] = 1] = "Green"; Color[Color["Blue"] = 2] = "Blue";&#125;)(Color || (Color = &#123;&#125;));var color = Color.Green;// enum Color &#123;Red = 1, Green, Blue&#125; 指定从1开始编号// enum Color &#123;Red = 1, Green = 2, Blue = 4&#125; 手动赋值 3.3 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 二、TS 在 Vue2.x 的实践1. 构建通过官方脚手架构建安装 (Vue CLI 3)1234567// 1. 如果没有安装 Vue CLI 就先安装npm install --global @vue/cli// 2. 创建一个新工程，并选择 &quot;Manually select features (手动选择特性)&quot; 选项vue create project-name 然后，命令行会要求选择预设。使用箭头键选择 Manually select features。 接下来，只需确保选择了 TypeScript 和 Babel 选项，然后配置其余设置，设置完成 vue cli 就会开始安装依赖并设置项目 。 2. 目录解析安装完成打开项目，目录结构如下： 12345678910111213141516171819202122232425|-- project-name |-- .browserslistrc # browserslistrc 配置文件 (用于支持 Autoprefixer) |-- .gitignore |-- .eslintrc.js # eslint 相关配置 |-- babel.config.js # babel-loader 配置 |-- package-lock.json |-- package.json # package.json 依赖 |-- postcss.config.js # postcss 配置 |-- README.md |-- tsconfig.json # typescript 配置 |-- vue.config.js # vue-cli 配置 |-- public # 静态资源 (会被直接复制) | |-- favicon.ico # favicon图标 | |-- index.html # html模板 |-- src | |-- App.vue # 入口页面 | |-- main.ts # 入口文件 加载组件 初始化等 | |-- shims-tsx.d.ts | |-- shims-vue.d.ts | |-- assets # 主题 字体等静态资源 (由 webpack 处理加载) | |-- components # 全局组件 | |-- router # 路由 | |-- store # 全局 vuex store | |-- styles # 全局样式 | |-- views # 所有页面 ts构建的项目目录与之前用js构建的区别不大，区别主要是之前 js 后缀的现在改为了ts后缀，还多了tsconfig.json、shims-tsx.d.ts、shims-vue.d.ts这几个文件： tsconfig.json: typescript配置文件,主要用于指定待编译的文件和定义编译选项 shims-tsx.d.ts: 允许.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码 shims-vue.d.ts: 主要用于 TypeScript 识别.vue 文件，Ts 默认并不支持导入 vue 文件 tsconfig.json 推荐配置123456789101112// tsconfig.json&#123; "compilerOptions": &#123; // 与 Vue 的浏览器支持保持一致 "target": "es5", // 这可以对 `this` 上的数据 property 进行更严格的推断 "strict": true, // 如果使用 webpack 2+ 或 rollup，可以利用 tree-shake: "module": "es2015", "moduleResolution": "node" &#125;&#125; 注意: 需要引入 strict: true (或者至少 noImplicitThis: true，这是 strict 模式的一部分) 以利用组件方法中 this 的类型检查，否则它会始终被看作 any 类型。 3. 使用3.1 在 vue 中使用 typescript 常用的几个库 vue-class-component: 是一个 Class Decorator，该库通过装饰器模式实现了 vue 的 ts 适配，也是官方推荐的使用 ts 方式 vue-property-decorator: 是在 vue-class-component 基础上进行了修改与扩充 vuex-module-decorators: 是在 typeScript 环境下中使用 vuex 的一种解决方案 3.2 上手要让 TypeScript 正确推断 Vue 组件选项中的类型，我们需要使用 Vue.component 或 Vue.extend 定义组件。 3.2.1 vue-class-component vue-class-component 对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化 1234567891011121314151617181920212223242526272829303132&lt;script&gt;import Vue from &apos;vue&apos;import Component from &apos;vue-class-component&apos;@Component(&#123; props: &#123; propMessage: String &#125;&#125;)export default class App extends Vue &#123; // initial data msg = 123 // use prop values for initial data helloMsg = &apos;Hello, &apos; + this.propMessage // lifecycle hook mounted () &#123; this.greet() &#125; // computed get computedMsg () &#123; return &apos;computed &apos; + this.msg &#125; // method greet () &#123; alert(&apos;greeting: &apos; + this.msg) &#125;&#125;&lt;/script&gt; 3.2.2 vue-property-decoratorvue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器： @Emit @Inject @Model @Prop @Provide @Watch @Component (从 vue-class-component 继承) (1) 组件声明 引入组件：和原生写法一致，都需要先引入再注册 12345678910111213&lt;script lang=&quot;ts&quot;&gt;import &#123; Component, Vue &#125; from &apos;vue-property-decorator&apos;;import HelloWorld from &apos;./components/HelloWorld.vue&apos;;@Component(&#123; components: &#123; HelloWorld, &#125;,&#125;)export default class App extends Vue &#123;&#125;&lt;/script&gt; (2) 响应式data 和 Prop声明 data 类语法中可以直接定义为类的实例属性作为组件的响应式数据 prop 类语法实现组件 props 定义是通过装饰器@Prop实现 12345678&lt;script lang=&quot;ts&quot;&gt;import &#123; Component, Prop, Vue &#125; from &apos;vue-property-decorator&apos;;@Componentexport default class HelloWorld extends Vue &#123; private name: string; @Prop() private msg!: string;&#125; !: 表示一定存在，?: 表示可能不存在。这两种在语法上叫赋值断言 @Prop(options: (PropOptions | Constructor[] | Constructor) = {}) PropOptions，可以使用以下选项：type，default，required，validator Constructor[]，指定 prop 的可选类型 Constructor，例如 String，Number，Boolean 等，指定 prop 的类型 (3) 生命周期函数生命周期钩子的使用和原先使用的区别：在类语法中直接将生命周期生命为方法(方法名称和生命周期名称一致)。 123456public created(): void &#123; console.log('created');&#125;public mounted(): void &#123; console.log('mounted')&#125; (4) Watch 监听属性类语法实现响应式的数据监听，是由 vue-property-decorator 依赖提供 @Watch 装饰器来完成。 @Watch(path: string, options: WatchOptions = {}) 其中，options 包含两个属性 immediate?:boolean 侦听开始之后是否立即调用该回调函数 deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数 123456789101112import &#123; Vue, Component &#125; from 'vue-property-decorator';@Componentexport default class Index extends Vue &#123; //watch定义，其中Wacth装饰器第一个参数：响应式数据字符串(也可以定义为'a.b'); //第二个参数options成员[immediate,deep]分别对应的是原生的用法 @Watch('$route', &#123; immediate: true &#125;) private changeRouter(val: Route, oldVal: Route) &#123; console.log('$route watcher: ', val, oldVal); &#125;&#125; (5) computed 计算属性类语法中的计算属性的实现，是通过 get 取值函数。 123public get getName() &#123; return 'computed ' + this.name;&#125; getName 是计算后的值，name 是被监听的值 (6) method在类语法实现原生 vue 的方法的方式，即通过直接定义类方法成员。 1234public clickFunc(): void &#123; console.log(this.name) console.log(this.msg)&#125; (7) 事件触发ts 环境下 vue 的事件触发方式和 js 环境下是一致的，区别只是事件回调定义的地方不同（ts 定义为类的实例方法，js 定义在 methods 属性中）。 (8) ref类语法中使用 ref 需要借助vue-property-decorator提供的@Ref装饰器 (9) mixins类语法使用 mixins 需要继承vue-property-decorator提供的 Mixins 函数所生成的类。 Mixins 函数的参数是 Vue 实例类 (10) slots 和 scopedSlotsslots 和 scopedSlots 的使用方式和原生 vue 保持一致。 三、tsconfig.json概述如果一个目录下存在一个 tsconfig.json 文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译： 使用tsconfig.json 不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。 不带任何输入文件的情况下调用tsc，且使用命令行参数--project（或-p）指定一个包含tsconfig.json文件的目录。 当命令行上指定了输入文件时，tsconfig.json文件会被忽略。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // 编译选项 "compilerOptions": &#123; // 编译输出目标 ES 版本 "target": "esnext", // 采用的模块系统 "module": "es2015", // 以严格模式解析 "strict": true, "jsx": "preserve", // 如何处理模块 "moduleResolution": "node", // 启用装饰器 "experimentalDecorators": true, // 允许从没有设置默认导出的模块中默认导入 "allowSyntheticDefaultImports": true, // 定义一个变量就必须给它一个初始值 "strictPropertyInitialization" : false, // 允许编译javascript文件 "allowJs": true, // 是否包含可以用于 debug 的 sourceMap "sourceMap": true, // 忽略 this 的类型检查, Raise error on this expressions with an implied any type. "noImplicitThis": false, // 解析非相对模块名的基准目录 "baseUrl": ".", // 给错误和消息设置样式，使用颜色和上下文。 "pretty": true, // 设置引入的定义文件 "types": ["webpack-env", "mocha", "chai"], // 指定特殊模块的路径 "paths": &#123; "@/*": ["src/*"] &#125;, // 编译过程中需要引入的库文件的列表 "lib": ["esnext", "dom", "dom.iterable", "scripthost"] &#125;, // ts 管理的文件 "include": [ "src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx" ], // ts 排除的文件 "exclude": ["node_modules"]&#125; &quot;compilerOptions&quot;可以被忽略，这时编译器会使用默认值。在这里查看完整的编译器选项列表。 &quot;files&quot;指定一个包含相对或绝对文件路径的列表。 &quot;include&quot;和&quot;exclude&quot;属性指定一个文件glob匹配模式列表。 支持的glob通配符有： * 匹配0或多个字符（不包括目录分隔符） ? 匹配一个任意字符（不包括目录分隔符） **/ 递归匹配任意子目录]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index和层叠上下文]]></title>
    <url>%2F2021%2F04%2F10%2Fz-index%2B%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[一、层叠上下文、层叠等级和层叠顺序 层叠上下文(stacking context)层叠上下文是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。 一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Z轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。 层叠等级(stacking level，层叠级别/层叠水平) 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。 在其他普通元素中，它描述定义的是这些普通元素在Z轴上的上下顺序。 普通元素的层叠等级优先由其所在的层叠上下文决定。 层叠等级的比较只有在当前层叠上下文元素中才有意义;不同层叠上下文中比较层叠等级是没有意义的。 二、z-index 定义 z-index 属性设定了一个定位元素及其后代元素或 flex 项目的 z-order (元素的层叠顺序)。 当元素之间重叠的时候， z-index 较大的元素会覆盖较小的元素在上层进行显示（MDN）。 z-index 属性设置一个定位元素沿 z 轴的位置。z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。 （w3school） 默认值：auto 继承性：no 版本：CSS2 JS 语法：object.style.zIndex=”1” （auto|number） 生效：position: absolute/relative/fixed/sticky 浏览器支持：所有主流浏览器都支持 z-index 属性。 注释：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 取值1z-index: auto|number|initial|inherit; | 值 | 描述 || :——- | :————————— || auto | 默认。堆叠顺序与父元素相等。 || number | 设置元素的堆叠顺序。 | auto (当一个定位元素不设置z-index的时候，默认值就是auto) ​ 盒子不会创建一个新的本地层叠上下文。在当前层叠上下文中生成的盒子的层叠层级和父级盒子相同。 number ​ number（整型数字）是生成的盒子在当前层叠上下文中的层叠层级。此盒子也会创建一个层叠层级为 0 的本地层叠上下文。 ​ 这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。 规则对于一个已经定位的盒子（元素），z-index 属性指定： 盒子在当前层叠上下文中的层叠层级。 盒子是否创建一个本地层叠上下文 同级 指的是同一个层叠上下文。当给z-index设置值的时候就会创建层叠上下文，不同的层叠上下文看最外层的z-index值。 具体来说，如果A的z-index比B的z-index小，那么A元素里面的其他元素无论设置多大的值也无法覆盖B里面的元素。 同级 下，z-index的值越大，层叠顺序越靠前，相同的z-index值的时候，后面的会在前面的层级之上。z-index的值是可以设置0和负数的。 同级 下，z-index: 0 的层级比auto高 注意：A元素(子元素A1)，兄弟元素B(子元素B1)。 若 A: 0，B: 1 （A &lt; B） A1 &lt; B A1 &lt; B1 若 A: auto，A1 &gt; B （A1直接可以跟B比） A1 &gt; B1 若A: auto，A1: -1 A1 &lt; A 若A: integer A1 &gt; A]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 判断对象是不是数组]]></title>
    <url>%2F2019%2F10%2F28%2FJS%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[JS 判断对象是不是数组前端面试或笔试经典题目之一——判断对象/数组 一、用 instanceof 操作符判断 instanceof运算符可以用来判断某个构造函数的prototype属性所指向的对象是否存在于另外一个要检测对象的原型链上 12345const a = [];const b = &#123;&#125;;console.log(a instanceof Array); //trueconsole.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数console.log(b instanceof Array); //false 注意：instanceof操作符的问题在于，它假定只有一个全局环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。 如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 二、用对象的 constructor 属性判断 实例化的数组拥有一个constructor属性，这个属性指向生成这个数组的方法 1234const a = [];const b = &#123;&#125;console.log(a.constructor == Array); //trueconsole.log(b.constructor == Array); //false 注意： constructor属性是可以被重写的 。 constructor属性一旦被修改，就不能确保一定是数组 。因此， 这种方法来判断数组是不靠谱的 。 三、用 Object.prototype.toString 判断 每一个继承自Object的对象都拥有toString的方法 使用call或者apply方法来改变toString方法的执行上下文 1234const a = []const b = &#123;&#125;console.log(Object.prototype.toString.call(a)==='[object Array]') // trueconsole.log(Object.prototype.toString.call(b)==='[object Array]') // false 四、用 Array.isArray()判断Array.isArray() 用于确定传递的值是否是一个数组 1234const a = [];const b = &#123;&#125;;Array.isArray(a);//trueArray.isArray(b);//false 目前所有主流浏览器和IE9+都对其进行了支持，IE8及以下浏览器不支持该方法 Polyfill—— 假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。 12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 数组去重(一)]]></title>
    <url>%2F2019%2F10%2F04%2FJavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[JavaScript 数组去重(一)前端面试或笔试经典题目之一——数组去重 一、ES6 + Set 去重法 可以去重 NaN 无法去重[], {} 12345function unique (arr) &#123; return Array.from(new Set(arr)) // or // return [...new Set(arr)]&#125; 二、for循环 + indexOf+ splice 去重法for循环倒序遍历，利用indexOf查找遍历值的索引，并用splice去重 由于NaN !== NaN ，因此当多个NaN 存在时，不会去重NaN 无法去重[], {} 12345678910function unique (arr) &#123; for (var i = arr.length -1;i &gt; 0; i--)&#123; // 循环遍历，从后面开始遍历不用管位置问题 if (arr.slice(0, i).indexOf(arr[i]) !== -1) &#123; // 元素与前面的所有元素比较，如果前面存在相同的则删掉自身 arr.splice(i, 1) &#125; &#125; return arr&#125; 三、forEach + indexOf + 新数组 去重法新建一个空数组，for 循环原数组，判断结果数组是否存在当前元素. 如果有相同的值则跳过，不相同则push进数组 由于NaN !== NaN ，因此当多个NaN 存在时，不会去重NaN 无法去重[], {} 123456789function unique (arr) &#123; let a = [] arr.forEach(i=&gt;&#123; if(a.indexOf(i) === -1) a.push(i) &#125;) return a&#125; 四、fillter +indexOf 去重法使用数组的filter方法和数组的indexOf方法 无法去重[], {} NaN 被删除了 12345function unique(arr) &#123; return arr.filter(function(item, index, arr)&#123; return arr.indexOf(item) === index; &#125;) &#125; 五、filter + hasOwnProperty 去重法使用数组的filter方法和对象的hasOwnProperty方法 123456function unique(arr) &#123; let obj = &#123;&#125;; return arr.filter(function(item, index, arr)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125;]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ES6学习」解构赋值（二）]]></title>
    <url>%2F2019%2F09%2F16%2F%E3%80%8CES6%E5%AD%A6%E4%B9%A0%E3%80%8D%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%20(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[「ES6学习」解构赋值（二）注：本文参考文章 阮一峰 ECMAScript 6 入门 引言 按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 解构赋值语法是一种 JavaScript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 变量的解构赋值主要有： 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 对象的解构赋值对象的解构与数组的重要不同之处 数组的元素按次序排列，变量的取值由它的位置决定； 对象的元素/属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; a, b &#125; = &#123; b:'bb', a:'aa'&#125;;// a="aa"; b="bb"// 次序不一致，对取值没有影响let &#123; test &#125; = &#123; Test: 'aa', text:'bb'&#125;;// test=undefined// 没有对应的同名属性：解构失败，变量的值等于undefined 可以将现有对象的方法，赋值到某个变量12345// Math 对象let &#123; log, sin, cos &#125; = Math;// console 对象const &#123; log &#125; = console;log('hello') // hello 如果变量名与属性名不一致，必须写成下面这样 12let &#123; first: f, last: l &#125; = &#123; first: 'hello', last: 'world' &#125;;//f='hello'; l='world' 对象的解构赋值的内部机制 先找到同名属性，然后再赋给对应的变量 真正被赋值的是后者，而不是前者 1234let &#123; first: one &#125; = &#123; first: '1', second: '2' &#125;;one // "1"first // Uncaught ReferenceError: first is not defined first是匹配的模式，one才是变量。真正被赋值的是变量one，而不是模式first。 嵌套结构的对象12345678910111213const obj = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = obj;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 三次解构赋值，分别是对loc、start、line三个属性的解构赋值。 注意: 最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 默认值默认值生效的条件是，对象的属性值严格等于undefined 12345var &#123;x = 1&#125; = &#123;x: undefined&#125;;x // 1var &#123;x = 1&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值1不会生效。 注意点：1. 将一个已经声明的变量用于解构赋值 1234567// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;; // SyntaxError: syntax error// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); // 将整个解构赋值语句，放在一个圆括号里面，就可以正确执行 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 2. 解构赋值允许等号左边的模式之中，不放置任何变量名。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 3. 由于数组本质是 特殊的对象 ，因此可以对数组进行对象属性的解构 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串的解构赋值 —— 字符串被转换成了一个 类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性 12let &#123;length : len&#125; = 'hello';len // 5]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ES6学习」解构赋值（一）]]></title>
    <url>%2F2019%2F09%2F14%2F%E3%80%8CES6%E5%AD%A6%E4%B9%A0%E3%80%8D%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%20(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[「ES6学习」解构赋值（一）注：本文参考文章 阮一峰 ECMAScript 6 入门 引言 按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 解构赋值语法是一种 JavaScript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 变量的解构赋值主要有： 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 数组的解构赋值从数组中提取值，按照对应位置，对变量赋值：1let [a, b, c] = [1, 2, 3]; 模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值 嵌套数组的解构12345let [a, [[b], c]] = [1, [[2], 3]]; // a=1;b=2; c=3let [ , , third] = ["a", "b", "c"]; // third="c"let [x, , y] = [1, 2, 3]; // x=1; y=3let [head, ...tail] = [1, 2, 3, 4]; // head=1; tail=[2, 3, 4]let [i, j, ...k] = ['a']; // i="a"; j=undefined; k=[] 注意：如果解构不成功，变量的值就等于undefined，而 rest 参数的值为[] 不完全解构 等号左边的模式 只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功 12let [x, y] = [1, 2, 3]; // x=1; y=2let [a, [b], d] = [1, [2, 3], 4]; // a=1; b=2; d=4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; Iterator 接口只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 对于 Set 结构，也可以使用数组的解构赋值。 1let [x, y, z] = new Set(['a', 'b', 'c']); // x="a" 默认值解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效 （如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined） 12let [x = 1] = [undefined]; // x=1let [x = 1] = [null]; // x=null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (三)]]></title>
    <url>%2F2019%2F08%2F16%2Fvar%20let%E5%92%8Cconst(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (三)前言在前一篇文章中，我们讲到了 var、let 和 const 有关的变量提升和函数提升。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 今天，我们来学习下 var、let 和 const的其他区别点：暂时性死区，重复声明和初始值 1. 暂时性死区(1) 什么是暂时性死区ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”（Temporal Dead Zone，简称 TDZ）。 理解：只要块级作用域内存在 let 或 const 命令，它所声明的变量就绑定（binding）这个区域，不再受外部影响。当进入这个区域，let 或者const 声明的变量不能被访问（获取或设置）直到执行到达声明。 123456789101112if (true) &#123; // TDZ 开始 tmp = 'a'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ 结束 console.log(tmp); // undefined tmp = 1; console.log(tmp); // 1 &#125; 代码理解：在块级作用域内，一开始存在全局变量 tmp。但是，接下来的 let 声明了一个局部变量 tmp，导致后者绑定了这个块级作用域。所以在 let 声明变量前，对 tmp 赋值会报错（ReferenceError）。 本质：只要一进入块级作用域，所要使用的变量 tmp 就已经存在了，但是不可获取。只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 (2) typeof 陷阱 当一个变量没有被声明时，使用 typeof 是不会报错的 1typeof undeclared_variable // "undefined" undeclared_variable 是一个不存在的变量名，结果返回“undefined” “暂时性死区” 意味着 typeof 不再是一个百分之百安全的操作。 12typeof x; // 报错！ ReferenceErrorlet x; 变量 x 使用 let 命令声明，所以在声明之前，都属于 x 的“暂时性死区”，只要用到该变量就会报错。 因此，typeof 运行时就会抛出一个ReferenceError 总结： typeof运算符并非是百分之百安全的，因此我们要养成良好的编程习惯，变量一定要在声明之后使用，否则就报错 （3） 其他例子实际上，有些 “死区” 比较隐蔽，不太容易发现。 1234function fun(x = y, y = 2) &#123; return [x, y];&#125;fun(); // 报错 上面代码中，调用 fun 函数之所以报错（某些实现 可能不会报错），是因为参数 x 默认值等于另一个参数 y ，而此时 y 还没有声明，属于”死区“。 如果 y 的默认值是 x ，就不会报错，因为此时 x 已经声明了。 1234function fun(x = 2, y = x) &#123; return [x, y];&#125;fun(); // [2, 2] 此外，下面的代码也会报错，与 var 的行为不同。 123456// 不报错var x = x;// 报错let x = x; // ReferenceError 上面代码报错，也是因为暂时性死区。使用 let 声明变量时，只要变量在还没有声明完成前使用，就会报错。 上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x未定义“。 (4) 总结ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 2. 重复声明定义：指在相同作用域内，重复声明同一个变量。 let 和 const 命令声明的变量不允许重复声明，而 var 可以重复声明。 在一个作用域中，已经用 var、let、cons t声明过某标识符之后，不能在用 let、const声明变量，不然会抛出错误。 12345678let a = 1;let a = 0; // 报错! Uncaught SyntaxError: Identifier 'a' has already been declaredconst PI = 3.14const PI = 3.1415 // 报错! Uncaught SyntaxError: Identifier 'a' has already been declaredvar b = 1;var b = 0; 在作用域中,嵌套一个作用域就不会报错了 12345var a = 1;if (true) &#123; let a = 0;&#125;// 不会报错 3. 初始值 和 const let 和 var 声明变量时，可以不需要初始值，而 const 需要。 const 声明的是只读的常量，一旦声明，就必须立即初始化（赋值），否则会报错 const 声明之后 值不能改变。 123const PI = 3.14;PI = 3.1415; // 报错! Uncaught TypeError: Assignment to constant variable. 如果 const 声明的是一个引用类型，则不能改变它的内存地址 本质：const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个 内存地址所保存的数据 不得改动。 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。 对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 举例如下 12345678const obj = &#123; a : '123'&#125;obj.a = 'abc';// 不会发生报错，只会改变值obj = &#123;&#125;;// 由于改变了对象的指针，所以会发生报错 // Uncaught TypeError: Assignment to constant variable. 如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze(&#123;&#125;); // 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 补充：顶层对象的属性let、const 和 class 命令声明的全局变量，不属于顶层对象的属性。 从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 全局作用域中，var 声明的变量关联到顶层对象的属性 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 参考文章 阮一峰 ECMAScript 6 入门]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (二)]]></title>
    <url>%2F2019%2F08%2F15%2Fvar%20let%E5%92%8Cconst(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (二)前言在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。在前一篇文章中，我们讲到了 var、let 和 const 的块级作用域，今天我们主要学习下变量提升和函数提升。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 1. 变量提升定义：变量提升，即将变量声明提升到它所在作用域的最开始的部分。变量声明在编译阶段被处理，而变量赋值则留在原地等待执行。 var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 let 和 const不存在变量提升，所声明的变量一定要在声明后使用，否则报错。 下面给出代码来解释 var 命令 — 存在变量提升12345678910console.log(global); // undefinedvar global = 'global';console.log(global); // global function fn () &#123; console.log(a); // undefined var a = 'a'; console.log(a); // a&#125;fn(); 由于js的变量提升，导致代码实际上是按照以下来执行的 123456789101112var global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值console.log(global); // undefinedglobal = 'global'; // 此时才赋值console.log(global); // globalfunction fn () &#123; var a; // 变量提升，函数作用域范围内 console.log(a); // undefined a = 'a'; console.log(a); // a&#125;fn(); let — 不存在变量提升123console.log(a);let a = 1;//报错! Uncaught ReferenceError: Cannot access 'a' before initializatio const — 不存在变量提升 123console.log(a);const a = 1;//报错! Uncaught ReferenceError: Cannot access 'a' before initializatio 使用 let 和 const 命令声明变量之前，该变量是不可用的。 2. 函数提升​ JavaScript中，创建函数主要有两种方式：函数声明式和函数表达式。 1) 函数声明 (Function Declaration); 1234// 函数声明function funDeclaration(type)&#123; return type === "Declaration";&#125; 2) 函数表达式 (Function Expression)。 123456// 函数表达式var funExpression = function(type)&#123; return type === "Expression";&#125;// 或者let、const ​ 编译阶段，JavaScript 引擎能把 函数声明 提升到顶部（即使声明函数的代码在调用它的代码后面） 函数声明提升优先于变量声明 (函数的提升优先级最高)。 函数声明提升优于函数表达式(函数表达式实际上是变量声明的一种)。 下面给出代码来解释 函数声明 12345console.log(fn(1)); function fn(a) &#123; return a&#125;// 1 由于函数提升，函数声明被置于执行环境顶部，即使调用函数的代码在声明函数之前也可以正确访问。 函数表达式 var 123456789101112console.log(fn(1)); var fn = function (a) &#123; return a;&#125;//报错！Uncaught TypeError: fn is not a function// 相当于var fn;console.log(fn(1));fn = function (a) &#123; return a;&#125; let（const和let类似） 12345console.log(fn(1)); let fn = function (a) &#123; return a;&#125;// 报错！Uncaught ReferenceError: Cannot access 'fn' before initialization]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 var、let 和 const (一)]]></title>
    <url>%2F2019%2F08%2F13%2Fvar%20let%E5%92%8Cconst(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[浅谈 var、let 和 const (一)前言ES6新增了 let 和 const 两个关键字 ，用于声明变量，这两个命令和 var 有很多不同之处，两者之间也有一些细微的差别。 let 和 const 的用法类似于 var，但是 let 只在所在的代码块内有效，所以我们一般使用 let 替代 var, 用 const 来声明常量。 声明方式 变量提升 暂时性死区 重复声明 初始值 作用域 var 允许 不存在 允许 不需要 除块级 let 不允许 存在 不允许 不需要 块级 const 不允许 存在 不允许 需要 块级 今天我们主要学习下块级作用域。 块级作用域(1) ES5没有块级作用域​ 在ES6之前，没有块级作用域的概念，只有两种作用域，函数作用域和全局作用域。 所有的变量和函数声明都存在于这两种作用域中。 (2) 什么是块级作用域？我找了个定义如下： 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 举个例子 123456789101112// 例子1for(var i = 0; i &lt; 10; i++) &#123; console.log(i); // 最后一次循环i=9，循环结束i++后，i=10&#125;console.log(i);// 跳出 for 循环了，这里仍可以使用i变量// 例子2for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000);&#125; 执行例子1时，外层 console.log 会输出10，这是因为使用var声明的变量不具备块级作用域的特性。变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 执行例子2时，console.log 会输出10个10，这是因为 循环本身及十次 timeout 回调均共享唯一的变量 i 。当循环结束执行时，i 的值为10。 所以当第一个 timeout 执行时，调用的 i 为10。 注意：如果初始化变量时，没有使用 var声明，该变量会自动被添加到全局环境。 (3) ES5怎么创建块级作用域？立即执行函数“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 想进一步了解立即执行函数，可参考学习 IIFE学习 123(function() &#123; // 这里是块级作用域&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。 立即执行函数也可以理解为立即调用一个匿名函数，可以用来模拟块级作用域。 (4) ES6中的块级作用域在ES6中，我们用 let 和 const 关键字来实现块级作用域。（跨级作用域的特性，let，const是类似的，因此主要讲let） let声明的变量，只在所在的代码块{}内有效，在{}外不能访问（外层代码块不受内层代码块的影响） 1234&#123; let x = 1;&#125;// 此处不能使用x变量，否则报错 Uncaught ReferenceError: x is not defined for 循环中使用let，每一次循环的i其实都是一个新的变量 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了 参考文章：https://juejin.im/post/59e6a86d518825422c0cbb6f]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中JSON 类型 —— 数据的迭代]]></title>
    <url>%2F2019%2F08%2F10%2FJSON%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JS 中 JSON 类型—— 数据的迭代0. 什么是JSON？​ JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式，JSON 数据格式与语言无关，脱胎自JavaScript，但目前很多编程语言都支持JSON 格式数据的生成和解析（维基）。 1. json类型的数据​ JavaScript中，json类型的数据，有两种形式，一种是数组形式，另一种是对象形式 注意：json 与 js对象的区别 A. 为了统一解析，JSON的字符串规定必须用双引号&quot;&quot;，Object的键也必须用双引号&quot;&quot; B. JSON键值对中的值不能为方法、函数/undefined/NaN 数组形式用下标来定位元素，数组内的元素是对象形式的json数据 1234json1 = [ &#123;"key1":"value1"&#125;, &#123;"key2":"value2"&#125;] ​ 数组格式的json的迭代，可以使用js数组的遍历和迭代函数实现。 12345678910111213141516171819202122232425// 1.数组形式json_array = [ &#123;"key1":"value1"&#125;, &#123;"key2": [ &#123;"key21": "value21"&#125;, &#123;"key22": "value22"&#125; ] &#125;,]// 1）for infor (let key in json_array)&#123; console.log(key,json_array[key])&#125;// 2) for offor (let item of json_array)&#123; console.log(item)&#125;// 3) forEachjson_array.forEach(item=&gt; console.log(item)) 对象形式 1234567json2 = &#123; &quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:[ &#123;&quot;key21&quot;: &quot;value21&quot;&#125;, &#123;&quot;key22&quot;: &quot;value22&quot;&#125; ]&#125; ​ 对象格式的json的迭代，可以使用js对象的遍历方式实现。 12345678910111213141516171819202122232425262728// 2.对象形式json_obj = &#123; "key1":"value1", "key2":[ &#123;"key21": "value21"&#125;, &#123;"key22": "value22"&#125; ]&#125;// 1) for infor(let i in json_obj)&#123; console.log(i,json_obj[i])&#125;// 2) Object.keysObject.keys(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;)// 3) Reflect.ownKeysReflect.ownKeys(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;)// 4) Object.getOwnPropertynamesObject.getOwnPropertyNames(json_obj).forEach(key=&gt;&#123; console.log(key,json_obj[key])&#125;) 思考 — 若对象形式的json数据，存在多级嵌套，则用递归处理 综合两种形式和嵌套的json迭代函数——json_iteration 12345678910json_iteration = function(json)&#123; for(let key in json)&#123; if (typeof(json[key]) == 'object') &#123; json_iteration(json[key]) &#125; else&#123; console.log(key,json[key]) &#125; &#125;&#125;]]></content>
      <tags>
        <tag>JS</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F04%2F22%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 搭建个人博客什么是 Hexo？​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 在本地安装Hexo框架安装前提​ 在安装Hexo前，必须检查电脑中是否已安装下列应用程序（请自行Google，查询安装方法）： Node.js Git 安装Hexo使用 npm 安装 Hexo 12# 安装 Hexo 提供的脚手架 hexo-cli$ npm install -g hexo-cli 初始化Hexo初始化博客（此处命名为MyBlog，读者可以任意） 123456# 初始化$ hexo init MyBlog$ cd MyBlog# 安装依赖$ npm install 此时， blog文件下的目录如下： 1234567.├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 运行1234# 启动博客$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 浏览器查看在浏览器中打开 http://localhost:4000 ，页面呈现Hexo 默认主题的博客站点。 Hexo 常用命令1234567891011$ hexo new &quot;MyBlog&quot; # hexo n$ hexo publish # hexo p$ hexo generate # hexo g 生成静态网页$ hexo deploy # hexo d 开始部署$ hexo server # hexo s # Hexo 会监视文件变动并自动更新，无须重启服务器$ hexo server -s # 静态模式$ hexo server -p 8000 # 更改8000端口$ hexo server -i 192.168.1.0 # 定义 IP$ hexo clean # 清除缓存，网页正常情况下可以忽略此条命令 参考资料Hexo 官方文档]]></content>
      <tags>
        <tag>Front End</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小白入门]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前端小白入门0. 前言前端开发入门学习有：HTML、CSS、JavaScript（简称JS） 三个部分。一个基本的网站可以由多个网页组成，一个基本的网页由HTML CSS和JavaScript组成，也即结构层(HTML)、表示层(CSS)、行为层(JavaScript)。 1. 简介(1) HTML（超文本标记语言 Hyper Text Markup Language）HTML 是用来描述网页的一种语言。它通过标记符号来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（比如文字如何处理，画面如何安排，图片如何显示等）。浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容. (2) CSS(层叠样式表 Cascading Style Sheets)样式表定义如何显示 HTML 元素，就像 HTML的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。 (3) JS( JavaScript)Javascript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言。使用它的目的是与HTML超文本标记语言、Java脚本语言(Java小程序)一起实现在一个Web页面中链接多个对象，与Web客户交互作用。例如可以设置鼠标悬停效果，在客户端验证表单，创建定制的HTML页面，显示警告框，设置cookie等等。 (4) 联系简单来说（不严谨），Html就是框架，就是一个房子的顶梁柱，CSS就是刷墙的颜料，美化HTML，JavaScript是让HTML更生动，更好看，让网页会动起来（比如图片滚动） 2. 学习路线个人经验，学习前端的路线应该是Html(Html5)—&gt; CSS(CSS3)—&gt;JS—&gt;Jquery，由浅入深。学打好基础，学好html和css基础，再学JS（要求先掌握基本语法，再学应用，有点难，必须深入学习） 以下是个人觉得入门阶段应该熟练掌握的基础技能： HTML4，HTML5语法、标签、语义（基础） CSS2.1，CSS3规范，与HTML结合实现各种布局、效果（基础） 一个成熟的客户端javascript库，推荐jquery 一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟， HTTP 比较好的在线学习资源有 W3School 和 菜鸟教程，当然阅读官方文档学习是更好的选择 本文在此对HTML、CSS、JS的学习进行粗略介绍。 3. HTML HTML文档的后缀名 .html .htm Html的入门学习包括 Html文档结构，头部标签，文本标签，表格标签，超链接标签，图像标签，HTML5音频、视频标签，HTML5绘图标签，框架标签（不需重点学习），&lt; div &gt;标签，颜色设置，绝对路径和相对路径。 简单例子 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;前端小白&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS CSS文件的后缀名 .css CSS的定义分类 CSS的定义可以直接放在HTML元素的标签中，称为内联样式。其形式如下： 1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;This is a paragraph.&lt;/p&gt; CSS的定义可以放在HTML文件的 &lt;style&gt; 标签中，称为内部样式表。其形式如下： 1&lt;head&gt;&lt;style&gt;body&#123;background-color:yellow;&#125;&lt;/style&gt; &lt;/head&gt; CSS的定义也可以独立保存在一个扩展名为 .css的文件中，通过链接的方式包含在网页中，称为外部样式表。其形式如下： 1&lt;head&gt;&lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;foo.css&quot;&gt;&lt;/head&gt; CSS的入门学习包括 选择符，CSS的层叠性与优先次序，CSS文本属性，CSS表格属性，CSS的盒子模型和网页布局方式（定位功能和定位方式）。 5. JS JS文件的后缀名 .js JS的基本语法 必须掌握：常量和变量，数据类型，表达式和运算符，两种语句（循环和条件）以及最重要的函数。 CSS的入门学习包括 基本语法，面向对象特性（类和对象，内置对象，异常处理），在浏览器的应用（浏览器对象，JS在DOM中的应用方式，事件驱动和界面交互，JS在html5的应用等等。 6. 基本开发工具好用的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并解决问题，以下是个人觉得必备的前端开发工具： 文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便，当然notepad++，VScode等也是不错的选择。 浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持 调试工具：推荐Chrome自带的Chrome develop tools（F12），可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等 辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools（另学） 7. 后言学习方法 入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果（不喜欢看书籍的直接第二步） 在具备一定基础之后可以上网搜各种教程（包括视频教程，比如慕课网，网易云课堂）、demo，了解各种功能的实际用法和常见功能的实现方法 阅读HTML，CSS，JavaScript标准全面完善知识点 阅读前端牛人的博客、文章提升对知识的理解 善用搜索引擎（Google最好）]]></content>
      <tags>
        <tag>Front End</tag>
      </tags>
  </entry>
</search>
